// Improved schema with unified approach

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  DOCTOR
  PATIENT
  VISITOR // Add visitor as a role
}

enum AccountType {
  REGISTERED // Has email/password
  ANONYMOUS // Device-based only
}

enum DiagnosisStatus {
  PENDING
  REVIEWED
  CONFIRMED
  REJECTED
}

enum Gender {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

// Unified User model for both registered and anonymous users
model User {
  id String @id @default(uuid())

  // Account type determines if this is registered or anonymous
  accountType AccountType @default(ANONYMOUS)

  // Required for registered users, null for anonymous
  userName String? @unique
  email    String? @unique
  password String?

  // Required for all users (registered and anonymous)
  deviceId String   @unique // Make required for device tracking
  role     UserRole @default(VISITOR)
  fcmToken String
  isActive Boolean  @default(true)

  // Anonymous user specific fields
  lastSeen   DateTime @default(now())
  visitCount Int      @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations - unified for all user types
  notifications  Notification[]
  patientInfo    PatientInfo?
  doctorInfo     DoctorInfo?
  chatHistory    ChatHistory[]
  sentAIRequests AIRequest[]    @relation("UserRequestSender")
  receivedAIData AIRequest[]    @relation("UserDataReceiver")

  @@index([email])
  @@index([role])
  @@index([deviceId])
  @@index([accountType])
}

// Unified AI Request model
model AIRequest {
  id         String  @id @default(uuid())
  senderId   String
  receiverId String?

  dataOne     String
  dataTwo     String
  dataThree   String
  promptText  String   @db.Text
  aiResponse  String   @db.Text
  isProcessed Boolean  @default(false)
  isDelivered Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  sender   User  @relation("UserRequestSender", fields: [senderId], references: [id])
  receiver User? @relation("UserDataReceiver", fields: [receiverId], references: [id])

  @@index([senderId])
  @@index([receiverId])
  @@index([isProcessed])
  @@index([isDelivered])
}

// Unified Patient info for all user types
model PatientInfo {
  id             String   @id @default(uuid())
  userId         String   @unique
  dateOfBirth    DateTime
  gender         Gender
  phoneNumber    String
  address        String
  medicalHistory String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relation
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model DoctorInfo {
  id              String   @id @default(uuid())
  userId          String   @unique
  fullName        String
  specialization  String
  licenseNumber   String   @unique
  phoneNumber     String
  address         String
  experience      Int
  bio             String?
  consultationFee Decimal?
  isVerified      Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relation
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([specialization])
  @@index([isVerified])
}

// Unified notifications
model Notification {
  id        String   @id @default(uuid())
  userId    String
  title     String
  message   String   @db.Text
  type      String?
  data      Json?
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  // Relation
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
  @@index([type])
}

// Unified chat history
model ChatHistory {
  id         String   @id @default(uuid())
  userId     String
  message    String   @db.Text
  aiResponse String   @db.Text
  sessionId  String?
  createdAt  DateTime @default(now())

  // Relation
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([sessionId])
  @@index([createdAt])
}
